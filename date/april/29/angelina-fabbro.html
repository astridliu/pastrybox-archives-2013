<!doctype html>
<html lang="en" class="">
  <head>
    <meta charset="utf-8">
    <title>The Pastry Box Project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@alexduloz">
    <style>
    	* {
    		margin: 0;
    		padding: 0;
    		-webkit-box-sizing: border-box;
  			-moz-box-sizing: border-box;
  			box-sizing: border-box;
    		}
    		
		body {
			width: 100%;
			max-width: 800px;
			padding: 40px 20px 0 20px;
			margin: 0 auto;
			padding-top: 40px;
			font-size: 24px;
			line-height: 1.4;
			color: #333;
			font-family: "Georgia", serif;
			overflow-y: scroll;
			}
		
		p, ul, ol, blockquote, figure, pre, iframe {
			margin-bottom: 30px;
			}
		
		h1, h2, h3, h4, h5, h6 {
			font-weight: bold;
			font-family: "Helvetica", sans-serif;
			margin-bottom: 0;
			}
		
		a {
			color: #333;
			text-decoration: none;
			border-bottom: 2px solid #333;
			}
		
		ul {
			list-style-type: disc;
			}
		
		ul, ol {
			padding-left: 25px;
			}
			
		li {
		 	margin-bottom: 5px;
		 	}
		 
		.thought-content {
			margin-bottom: 60px;
			border-bottom: 1px solid #aaa;
		 	}
		 
		.project {
		 	font-size: 30px;
		 	margin: 40px 0 60px 0;
		 	}
		 	
		blockquote {
		 	width: 75%;
		 	margin-left: auto;
		 	margin-right: auto;
		 	color: #777;
		 	border-left: double 4px #ccc;
		 	font-style: italic;
		 	padding-left: 20px;
		 	font-size: .9em;
		 	}
		 
		figcaption {
		 	text-align: right;
		 	}
		 
		code {
		 	border: 1px solid #ccc;
		 	border-radius: 3px;
		 	background: #fafafa;
		 	font-family: monospace;
		 	font-size: .9em;
		 	}
		 
		pre {
		 	background: #555;
		 	color: white;
		 	border-radius: 5px;
		 	padding: 10px;
		 	}
		 	
		pre code {
		 	border: 0;
		 	background: #555;
		 	font-size: .8em;
		 	white-space: pre-wrap;
		 	}

		.footnote {
			font-size: .8em;
			position: relative;
			color: #777;
			padding-top: .4em;
			}

		.footnote:before {
			content: "";
			display: block;
			position: absolute;
			left: 0;
			top: 0;
			height: 1px;
			background: #777;
			width: 20%;
			}

		hr {
		 	margin-bottom: 40px;
		 	}
		 
		.baked-by {
		 	font-weight: bold;
		 	}
		 	
    </style>
  </head>
  <body>
    
    <p class="project">The Pastry Box Project</p>

    
    <h1>Monday, 29 April 2013</h1>
    
    <p class="baked-by">baked by Angelina Fabbro</p>
    
    <div class="thought-content">
       <h1>Signs of Programmer Expertise</h1><p>Last month I baked a strudel about <a href="http://the-pastry-box-project.net/angelina-fabbro/2013-march-28/">how to know you’re not a beginner anymore</a>. I found this exceptionally useful as a kind of lower-bound I could put on my skills and knowledge; I could say that there were topics I could move forward from and thus move towards more advanced material with confidence. This month, I’m baking a cookie about how I know that I’m not a master at programming. In fact, I’d even go as far to say that there are no masters.</p><p>There is no such thing as a grand ultimate master of programming because the goalposts will always keep moving. If we were to take the top ten percent of programmers, we could say that those programmers are probably experts. We would still have the problem of defining what criteria includes people in that ten percent, which is an altogether different matter. But a master? The term ‘master’ in the context of ability is usually reserved for someone who has studied an art or science so thoroughly that they have complete knowledge and skill over said art or science. When it comes to programming, there are no masters because the landscape of programming changes dramatically as new technology is forged.</p><p>There are always new tools. There will be new languages. The hardware will change. The software will have to adapt. You will have to change. You will have to adapt.</p><p><strong>Sign of Programmer Expertise #1:</strong> The programmer understands that the learning will never stop and is at peace with how quickly the tools and landscape change.</p><p>The expert who you look up to — you know the one, they’ve written that sweet library you use so much, and you’ve read all of their books — cannot and should never halt on the notion that they have achieved mastery. Programming will move on without them. Maybe they’ll have mastered programming circa the year 2013, but the rest of us will go on without them if they stop there.</p><p>So what about that top ten percent? We know it is unrealistic to say we will be masters of this domain. We made peace with that at the end of the last paragraph. How do we approach criteria that describes someone as an expert programmer? The dialogue is ongoing, and I hope that through it we’ll eventually be able to convey to those who want to learn programming the kind of expectations they have to meet to be the best of the best.</p><p><strong>Sign of Programmer Expertise #2:</strong> If you are an expert at programming, in at least one language you must be able to code as though you have a gun to your head, without a language reference.<sup><a href="#fn1" id="r1" class="footnote-jump">*</a></sup></p><p>I know what you’re thinking, that most programmers always have a browser tab open with an API or language reference. Nobody actually codes without at least some of that stuff in their day-to-day job. I know I do. This makes sense for when you are trying to make something for someone else and you are on a budget of time, money, or both. Often it makes sense for you personally too, when you’re on your own time making your own wonderful thing. Because you value your time, you want to have all the resources you need so that you don’t have to remember the name of a function that you’ve forgotten while you remember the essence of what that function is supposed to do. You want to accomplish building something for yourself in a reasonable amount of time.</p><p>This is good for building things and shipping them, but what it’s not good for is your mastery of programming.</p><p>This may seem in direct contradiction to what I said last month. In my last pastry, I explained that you have to be able to program in different languages than the one you are most comfortable with to say that you really know programming and not just the language. This is true. However, this is like saying that if you are learning to swing a sword, you should be able to use almost any sword. There are differences between a broadsword and a rapier, but by understanding the basics you can probably figure out how to use each reasonably well. Despite this, a swordsperson probably has a preferred type of sword, and since there are all subtle differences between them the swordsperson will probably only be able to become an expert with one or two. The same is true with programming languages. While you can broadly apply your skills to any language to create something, it is the concise practice of a few languages that will yield you the most satisfying results.</p><p><strong>Sign of Programmer Expertise #3:</strong> The programmer is not merely satisfied with solving the problem, they insist upon solving it in an efficient and robust manner.</p><p>I’ve had so many people ask me, ‘how do I know if my software design patterns are good, and how do I measure that? ’. Write tests. Measure execution time, function complexity, memory usage, and whatever else you can think of. Benchmark your code against other code. If you can balance your optimizations with code readability, then your design pattern is probably pretty good. The numbers won’t lie, so stick to those and don’t worry about much else.</p><p><strong>Sign of Programmer Expertise #4:</strong> The programmer knows how their parser/compiler/interpreter works. Intimately.</p><p>The programmer who wants to get better at designing software will inevitably get to a point where they can only optimize so far without an understanding of how their language is parsed, processed, compiled, etc. To know the nuances of how the machines speak your language is as big an endeavour as learning the language itself. It will require you to think about your language by picking it apart instruction by instruction to see how it was designed. At some point, you should aim to write a programming language or compiler/interpreter just to understand what the designers of a language or compiler/interpreter had to consider when making the ones you work with every day. You’ll understand the concessions and caveats that cause the quirks of your language that you never had reason to understand before. This will help you learn your language inside and out — I mean you will <em>literally</em> know it’s insides.</p><p><strong>Sign of Programmer Expertise #5: ???</strong></p><p>As I’ve mentioned before, this is an ongoing dialogue. I’m hoping that the few ideas I’ve exposed here are enough to get you thinking about where you want to go next with your programming skill, and that someone out there will tell me what the #5, or #6, or #7… in this list should be. I have no idea. I’m just doing the same thing that the rest of you are doing; I’m trying to navigate my way through the ridiculous amount of information available to pick and choose the most reasonable course for success. So, if you know what comes next — tell me. I’m all ears.</p><p id="fn1" class="footnote"><a href="#r1">*</a>Baker’s note: Please don’t ever, ever put a gun to your head even as a joke.</li> </p>
    </div>
  
  </body>
</html>