

# Signs of Programmer Expertise

Last month I baked a strudel about [how to know you’re not a beginner
anymore](http://the-pastry-box-project.net/angelina-fabbro/2013-march-28/). I found this exceptionally useful
as a kind of lower-bound I could put on my skills and knowledge; I could say that there were topics I could
move forward from and thus move towards more advanced material with confidence. This month, I’m baking a
cookie about how I know that I’m not a master at programming. In fact, I’d even go as far to say that
there are no masters.

There is no such thing as a grand ultimate master of programming because the goalposts will always keep
moving. If we were to take the top ten percent of programmers, we could say that those programmers are
probably experts. We would still have the problem of defining what criteria includes people in that ten
percent, which is an altogether different matter. But a master? The term ‘master’ in the context of
ability is usually reserved for someone who has studied an art or science so thoroughly that they have
complete knowledge and skill over said art or science. When it comes to programming, there are no masters
because the landscape of programming changes dramatically as new technology is forged.

There are always new tools. There will be new languages. The hardware will change. The software will have to
adapt. You will have to change. You will have to adapt.

__Sign of Programmer Expertise #1:__ The programmer understands that the learning will never stop and is at
peace with how quickly the tools and landscape change.

The expert who you look up to — you know the one, they’ve written that sweet library you use so much, and
you’ve read all of their books — cannot and should never halt on the notion that they have achieved
mastery. Programming will move on without them. Maybe they’ll have mastered programming circa the year 2013,
but the rest of us will go on without them if they stop there.

So what about that top ten percent? We know it is unrealistic to say we will be masters of this domain. We
made peace with that at the end of the last paragraph. How do we approach criteria that describes someone as
an expert programmer? The dialogue is ongoing, and I hope that through it we’ll eventually be able to convey
to those who want to learn programming the kind of expectations they have to meet to be the best of the
best.

__Sign of Programmer Expertise #2:__ If you are an expert at programming, in at least one language you must be
able to code as though you have a gun to your head, without a language reference.[*](#fn1)

I know what you’re thinking, that most programmers always have a browser tab open with an API or language
reference. Nobody actually codes without at least some of that stuff in their day-to-day job. I know I do.
This makes sense for when you are trying to make something for someone else and you are on a budget of time,
money, or both. Often it makes sense for you personally too, when you’re on your own time making your own
wonderful thing. Because you value your time, you want to have all the resources you need so that you don’t
have to remember the name of a function that you’ve forgotten while you remember the essence of what that
function is supposed to do. You want to accomplish building something for yourself in a reasonable amount of
time.

This is good for building things and shipping them, but what it’s not good for is your mastery of
programming.

This may seem in direct contradiction to what I said last month. In my last pastry, I explained that you have
to be able to program in different languages than the one you are most comfortable with to say that you really
know programming and not just the language. This is true. However, this is like saying that if you are
learning to swing a sword, you should be able to use almost any sword. There are differences between a
broadsword and a rapier, but by understanding the basics you can probably figure out how to use each
reasonably well. Despite this, a swordsperson probably has a preferred type of sword, and since there are all
subtle differences between them the swordsperson will probably only be able to become an expert with one or
two. The same is true with programming languages. While you can broadly apply your skills to any language to
create something, it is the concise practice of a few languages that will yield you the most satisfying
results.

__Sign of Programmer Expertise #3:__ The programmer is not merely satisfied with solving the problem, they
insist upon solving it in an efficient and robust manner.

I’ve had so many people ask me, ‘how do I know if my software design patterns are good, and how do I
measure that? ’. Write tests. Measure execution time, function complexity, memory usage, and whatever else
you can think of. Benchmark your code against other code. If you can balance your optimizations with code
readability, then your design pattern is probably pretty good. The numbers won’t lie, so stick to those and
don’t worry about much else.

__Sign of Programmer Expertise #4:__ The programmer knows how their parser/compiler/interpreter works.
Intimately.

The programmer who wants to get better at designing software will inevitably get to a point where they can
only optimize so far without an understanding of how their language is parsed, processed, compiled, etc. To
know the nuances of how the machines speak your language is as big an endeavour as learning the language
itself. It will require you to think about your language by picking it apart instruction by instruction to see
how it was designed. At some point, you should aim to write a programming language or compiler/interpreter
just to understand what the designers of a language or compiler/interpreter had to consider when making the
ones you work with every day. You’ll understand the concessions and caveats that cause the quirks of your
language that you never had reason to understand before. This will help you learn your language inside and out
— I mean you will *literally* know it’s insides.

__Sign of Programmer Expertise #5: ???__

As I’ve mentioned before, this is an ongoing dialogue. I’m hoping that the few ideas I’ve exposed here
are enough to get you thinking about where you want to go next with your programming skill, and that someone
out there will tell me what the #5, or #6, or #7… in this list should be. I have no idea. I’m just doing
the same thing that the rest of you are doing; I’m trying to navigate my way through the ridiculous amount
of information available to pick and choose the most reasonable course for success. So, if you know what comes
next — tell me. I’m all ears.

[*](#r1)Baker’s note: Please don’t ever, ever put a gun to your head even as a joke. 